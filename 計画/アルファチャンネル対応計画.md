# アルファチャンネル処理対応計画

## 問題の概要

現在の実装では「RGB のいずれかが存在する場合255, それ以外は0」という処理により、黒色（R=0, G=0, B=0, A=255）が透明として扱われてしまう問題がある。

### 具体的な問題

1. **黒色透明化問題**: 黒色(0,0,0,255)が透明(0,0,0,0)として処理される
2. **RGB同時移動問題**: RGB移動時に移動元が黒色(0,0,0)になり、不適切に透明化される

## 検討した対応策

### 方式A: 処理タイプ別アルファ判定
```typescript
// applyRandomGlitch: RGBチャンネル独立移動
if (hasAnyRGB) {
  alpha = 255;
} else {
  alpha = originalAlpha; // 元アルファ保持
}

// glitchImage: RGB同時移動
if (RGB移動モード && すべてのRGBが0) {
  alpha = 0; // 移動元は透明化
} else if (hasAnyRGB) {
  alpha = 255;
} else {
  alpha = originalAlpha; // 元アルファ保持
}
```

- **メリット**: 処理タイプに応じた適切な判定
- **デメリット**: 処理ごとに異なるロジック、複雑

### 方式B: 移動元/移動先判定
```typescript
const isMovedFrom = (移動処理で元の位置から色が移動された);
const isMovedTo = (移動処理で新しく色が追加された);

if (isMovedFrom && すべてのRGBが0) {
  alpha = 0; // 移動元は透明化
} else if (isMovedTo || hasAnyRGB) {
  alpha = 255; // 移動先または元から色がある
} else {
  alpha = originalAlpha; // 変更なし
}
```

- **メリット**: 移動の概念に基づく明確な判定
- **デメリット**: 移動元/先の判定が複雑

### 方式C: 二段階処理（推奨）
```typescript
// 1段階目: グリッチ処理（アルファは触らない）
// 2段階目: アルファ計算
for (各ピクセル) {
  const originalRGB = getOriginalRGB(pixel);
  const currentRGB = getCurrentRGB(pixel);
  const originalAlpha = getOriginalAlpha(pixel);
  
  if (originalAlpha === 0 && hasCurrentRGB) {
    // 透明だった場所に色追加 → 不透明
    alpha = 255;
  } else if (originalAlpha > 0 && !hasCurrentRGB) {
    // 色があった場所が無色 → 透明
    alpha = 0;
  } else if (originalAlpha > 0) {
    // 色があった場所（移動先含む） → 不透明
    alpha = 255;
  } else {
    // 透明で変化なし → 透明
    alpha = 0;
  }
}
```

- **メリット**: 元画像との差分に基づく論理的判定
- **デメリット**: 元画像データへのアクセスが必要

### 方式D: ピクセル状態管理
```typescript
// 各ピクセルの状態を管理
const pixelStates = new Map();

// 移動処理時に状態を記録
if (RGB移動) {
  pixelStates.set(fromIndex, 'moved_from');
  pixelStates.set(toIndex, 'moved_to');
}

// アルファ判定
const state = pixelStates.get(pixelIndex);
if (state === 'moved_from' && !hasRGB) {
  alpha = 0; // 移動元で空 → 透明
} else if (hasRGB || originalAlpha > 0) {
  alpha = 255; // 色があるか元から不透明 → 不透明
} else {
  alpha = 0; // 透明
}
```

- **メリット**: 精密な状態管理、理論的に最も正確
- **デメリット**: 実装が複雑、メモリ使用量増加

## 推奨方針: 方式C「二段階処理」

### 選択理由

1. **論理的明確性**: 元画像との差分で判定するため理解しやすい
2. **包括的対応**: 全ての移動パターン（単色、RGB同時）に対応可能
3. **実装の単純性**: 複雑な状態管理や条件分岐が不要
4. **直感的**: 「元あった色が消えたら透明、元なかった場所に色が来たら不透明」

### 実装ポイント

1. **元画像データの保持**: グリッチ処理前の画像データを参照用に保持
2. **グリッチ処理**: RGB チャンネルのみ処理、アルファは未処理のまま
3. **アルファ再計算**: 元画像と現在画像を比較してアルファ値を決定
4. **問題の同時解決**: 黒色問題と移動問題を一つのロジックで解決

### 実装の流れ

```typescript
// 1. 元画像データを保存
const originalImageData = new ImageData(...);

// 2. グリッチ処理（RGBのみ）
applyGlitchToRGB(imageData);

// 3. アルファ再計算
for (let i = 0; i < imageData.data.length; i += 4) {
  const originalR = originalImageData.data[i];
  const originalG = originalImageData.data[i + 1];
  const originalB = originalImageData.data[i + 2];
  const originalA = originalImageData.data[i + 3];
  
  const currentR = imageData.data[i];
  const currentG = imageData.data[i + 1];
  const currentB = imageData.data[i + 2];
  
  const hadColor = originalA > 0;
  const hasColor = currentR || currentG || currentB;
  
  if (!hadColor && hasColor) {
    // 透明 → 色追加: 不透明
    imageData.data[i + 3] = 255;
  } else if (hadColor && !hasColor) {
    // 色あり → 無色: 透明
    imageData.data[i + 3] = 0;
  } else if (hadColor) {
    // 色あり → 色あり: 不透明
    imageData.data[i + 3] = 255;
  } else {
    // 透明 → 透明: 透明
    imageData.data[i + 3] = 0;
  }
}
```

## 影響範囲

この修正により以下の関数が影響を受ける：

1. **`glitchImage`**: RGB同時移動時のアルファ処理
2. **`applyRandomGlitch`**: RGBチャンネル独立移動時のアルファ処理  
3. **`applyGlitchToSegment`**: セグメント処理時のアルファ処理

## 実装予定

1. 既存修正のコミット後に実装開始
2. 段階的な実装とテストを実施
3. 元実装との動作比較検証

---

**作成日**: 2025年8月16日  
**ステータス**: 計画策定完了、実装待ち